# coding: utf-8
"""Waylay Resources api tests.

This code was generated from the OpenAPI documentation of 'Waylay Resources'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import List, Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.resources.api import ResourceApi
from waylay.services.resources.service import ResourcesService

from ..types.patch_resource_entity_stub import PatchResourceEntityStub
from ..types.resource_change_stub import ResourceChangeStub
from ..types.resource_creation_response_stub import ResourceCreationResponseStub
from ..types.resource_entity_stub import ResourceEntityStub
from ..types.resource_id_stub import ResourceIdStub
from ..types.resource_listing_stub import ResourceListingStub
from ..types.resource_type_id_stub import ResourceTypeIdStub
from ..types.resource_with_id_entity_stub import ResourceWithIdEntityStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.resources.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.resources.models import (
        ResourceChange,
        ResourceCreationResponse,
        ResourceListing,
        ResourceWithIdEntity,
    )
    from waylay.services.resources.queries.resource_api import (
        GetQuery,
        ListChangesQuery,
        ListChildrenQuery,
        ListQuery,
        ListReferrersQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def resource_api(waylay_api_client: ApiClient) -> ResourceApi:
    return ResourceApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that ResourceApi api is registered in the sdk client."""
    assert isinstance(waylay_client.resources.resource, ResourceApi)


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = ResourceCreationResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/resources/v1/resources(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create
    Create Resource
    """
    # set path params
    kwargs = {
        "json": ResourceEntityStub.create_instance(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource.create(**kwargs)
    check_type(resp, Union[ResourceCreationResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Resource
    """
    # set path params
    kwargs = {
        "json": ResourceEntityStub.create_json(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource.create(**kwargs)
    check_type(resp, Model)


def _delete_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, resourceId: str):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}(\\?.*)?"
        ),
        "content": mock_response,
        "status_code": 204,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete
    Remove Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.delete(resourceId, **kwargs)
    assert not resp


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete with models not installed
    Remove Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.delete(resourceId, **kwargs)
    assert not resp


def _get_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, resourceId: str):
    mock_response = ResourceWithIdEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        # optionally use GetQuery to validate and reuse parameters
        "query": GetQuery(
            denormalized=True,
            field=[],
            fields=[],
        ),
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.get(resourceId, **kwargs)
    check_type(resp, Union[ResourceWithIdEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "query": {
            "denormalized": True,
            "field": [],
            "fields": [],
        },
    }
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.get(resourceId, **kwargs)
    check_type(resp, Model)


def _list_changes_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = [ResourceChangeStub.create_json()]
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}/changes(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_changes(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_changes
    List Resource Changes
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        # optionally use ListChangesQuery to validate and reuse parameters
        "query": ListChangesQuery(
            skip=0,
            limit=100,
        ),
    }
    _list_changes_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_changes(resourceId, **kwargs)
    check_type(resp, Union[List[ResourceChange],])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_changes_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_changes with models not installed
    List Resource Changes
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "query": {
            "skip": 0,
            "limit": 100,
        },
    }
    _list_changes_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_changes(resourceId, **kwargs)
    check_type(resp, Model)


def _list_children_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = ResourceListingStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}/children(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_children(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_children
    List Resource Children
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        # optionally use ListChildrenQuery to validate and reuse parameters
        "query": ListChildrenQuery(
            denormalized=True,
            field=[],
            fields=[],
            skip=0,
            limit=100,
        ),
    }
    _list_children_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_children(resourceId, **kwargs)
    check_type(resp, Union[ResourceListing,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_children_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_children with models not installed
    List Resource Children
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "query": {
            "denormalized": True,
            "field": [],
            "fields": [],
            "skip": 0,
            "limit": 100,
        },
    }
    _list_children_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_children(resourceId, **kwargs)
    check_type(resp, Model)


def _list_referrers_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = ResourceListingStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}/referrers(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list_referrers(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_referrers
    List Referring Resources
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        # optionally use ListReferrersQuery to validate and reuse parameters
        "query": ListReferrersQuery(
            field=[""],
            fields=[],
            skip=0,
            limit=100,
        ),
    }
    _list_referrers_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_referrers(resourceId, **kwargs)
    check_type(resp, Union[ResourceListing,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_referrers_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list_referrers with models not installed
    List Referring Resources
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "query": {
            "field": [""],
            "fields": [],
            "skip": 0,
            "limit": 100,
        },
    }
    _list_referrers_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.list_referrers(resourceId, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = ResourceListingStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/resources/v1/resources(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    Query Resources
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            skip=0,
            limit=100,
            field=[],
            fields=[],
            filter="needle",
            query="address.city:in(Ghent,Brussels)",
            tag=[],
            id=[],
            provider="provider_example",
            customer="customer_example",
            resource_type_id=ResourceTypeIdStub.create_json(),
            lat=3.4,
            lon=3.4,
            distance="distance_example",
            toplevel_only=true,
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource.list(**kwargs)
    check_type(resp, Union[ResourceListing,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    Query Resources
    """
    # set path params
    kwargs = {
        "query": {
            "skip": 0,
            "limit": 100,
            "field": [],
            "fields": [],
            "filter": "needle",
            "query": "address.city:in(Ghent,Brussels)",
            "tag": [],
            "id": [],
            "provider": "provider_example",
            "customer": "customer_example",
            "resourceTypeId": ResourceTypeIdStub.create_json(),
            "lat": 3.4,
            "lon": 3.4,
            "distance": "distance_example",
            "toplevelOnly": true,
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource.list(**kwargs)
    check_type(resp, Model)


def _patch_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str, resourceId: str):
    mock_response = ResourceWithIdEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "PATCH",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_patch(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch
    Create Or Update Resource Partially
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "json": PatchResourceEntityStub.create_instance(),
    }
    _patch_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.patch(resourceId, **kwargs)
    check_type(resp, Union[ResourceWithIdEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_patch_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for patch with models not installed
    Create Or Update Resource Partially
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "json": PatchResourceEntityStub.create_json(),
    }
    _patch_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.patch(resourceId, **kwargs)
    check_type(resp, Model)


def _replace_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceId: str
):
    mock_response = ResourceWithIdEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resources/{resourceId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_replace(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace
    Update Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "json": ResourceEntityStub.create_instance(),
    }
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.replace(resourceId, **kwargs)
    check_type(resp, Union[ResourceWithIdEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_replace_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace with models not installed
    Update Resource
    """
    # set path params
    resourceId = ResourceIdStub.create_json()

    kwargs = {
        "json": ResourceEntityStub.create_json(),
    }
    _replace_set_mock_response(httpx_mock, gateway_url, quote(str(resourceId)))
    resp = await service.resource.replace(resourceId, **kwargs)
    check_type(resp, Model)
