# coding: utf-8
"""Waylay Resources api tests.

This code was generated from the OpenAPI documentation of 'Waylay Resources'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import List, Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.resources.api import ResourceConstraintApi
from waylay.services.resources.service import ResourcesService

from ..types.constraint_stub import ConstraintStub
from ..types.resource_constraint_creation_response_stub import (
    ResourceConstraintCreationResponseStub,
)
from ..types.resource_constraint_with_id_entity_stub import (
    ResourceConstraintWithIdEntityStub,
)

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.resources.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.resources.models import (
        ResourceConstraintCreationResponse,
        ResourceConstraintWithIdEntity,
    )
    from waylay.services.resources.queries.resource_constraint_api import ListQuery


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def resource_constraint_api(waylay_api_client: ApiClient) -> ResourceConstraintApi:
    return ResourceConstraintApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that ResourceConstraintApi api is registered in the sdk client."""
    assert isinstance(
        waylay_client.resources.resource_constraint, ResourceConstraintApi
    )


def _create_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = ResourceConstraintCreationResponseStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/resources/v1/resourceconstraints(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 201,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_create(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create
    Create Resource Constraint
    """
    # set path params
    kwargs = {
        "json": ConstraintStub.create_instance(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource_constraint.create(**kwargs)
    check_type(resp, Union[ResourceConstraintCreationResponse,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_create_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for create with models not installed
    Create Resource Constraint
    """
    # set path params
    kwargs = {
        "json": ConstraintStub.create_json(),
    }
    _create_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource_constraint.create(**kwargs)
    check_type(resp, Model)


def _delete_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceConstraintId: str
):
    mock_response = None
    httpx_mock_kwargs = {
        "method": "DELETE",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resourceconstraints/{resourceConstraintId}(\\?.*)?"
        ),
        "content": mock_response,
        "status_code": 204,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_delete(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete
    Remove Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(resourceConstraintId)))
    resp = await service.resource_constraint.delete(resourceConstraintId, **kwargs)
    assert not resp


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_delete_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for delete with models not installed
    Remove Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {}
    _delete_set_mock_response(httpx_mock, gateway_url, quote(str(resourceConstraintId)))
    resp = await service.resource_constraint.delete(resourceConstraintId, **kwargs)
    assert not resp


def _get_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceConstraintId: str
):
    mock_response = ResourceConstraintWithIdEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resourceconstraints/{resourceConstraintId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_get(service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for get
    Get Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {}
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(resourceConstraintId)))
    resp = await service.resource_constraint.get(resourceConstraintId, **kwargs)
    check_type(resp, Union[ResourceConstraintWithIdEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_get_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for get with models not installed
    Get Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {}
    _get_set_mock_response(httpx_mock, gateway_url, quote(str(resourceConstraintId)))
    resp = await service.resource_constraint.get(resourceConstraintId, **kwargs)
    check_type(resp, Model)


def _list_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = [ResourceConstraintWithIdEntityStub.create_json()]
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/resources/v1/resourceconstraints(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_list(service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock):
    """Test case for list
    List Resource Constraints
    """
    # set path params
    kwargs = {
        # optionally use ListQuery to validate and reuse parameters
        "query": ListQuery(
            skip=0,
            limit=100,
            filter="needle",
            query="tags:technology",
        ),
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource_constraint.list(**kwargs)
    check_type(resp, Union[List[ResourceConstraintWithIdEntity],])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_list_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for list with models not installed
    List Resource Constraints
    """
    # set path params
    kwargs = {
        "query": {
            "skip": 0,
            "limit": 100,
            "filter": "needle",
            "query": "tags:technology",
        },
    }
    _list_set_mock_response(httpx_mock, gateway_url)
    resp = await service.resource_constraint.list(**kwargs)
    check_type(resp, Model)


def _replace_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, resourceConstraintId: str
):
    mock_response = ResourceConstraintWithIdEntityStub.create_json()
    httpx_mock_kwargs = {
        "method": "PUT",
        "url": re.compile(
            f"^{gateway_url}/resources/v1/resourceconstraints/{resourceConstraintId}(\\?.*)?"
        ),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_replace(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace
    Update Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {
        "json": ConstraintStub.create_instance(),
    }
    _replace_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceConstraintId))
    )
    resp = await service.resource_constraint.replace(resourceConstraintId, **kwargs)
    check_type(resp, Union[ResourceConstraintWithIdEntity,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_replace_without_types(
    service: ResourcesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for replace with models not installed
    Update Resource Constraint
    """
    # set path params
    resourceConstraintId = "resource_constraint_id_example"

    kwargs = {
        "json": ConstraintStub.create_json(),
    }
    _replace_set_mock_response(
        httpx_mock, gateway_url, quote(str(resourceConstraintId))
    )
    resp = await service.resource_constraint.replace(resourceConstraintId, **kwargs)
    check_type(resp, Model)
