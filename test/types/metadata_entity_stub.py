# coding: utf-8
"""Waylay Resources model tests.

This code was generated from the OpenAPI documentation of 'Waylay Resources'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json

from jsf import JSF
from pydantic import TypeAdapter

from ..openapi import MODEL_DEFINITIONS, with_example_provider

try:
    from waylay.services.resources.models.metadata_entity import MetadataEntity

    MetadataEntityAdapter = TypeAdapter(MetadataEntity)
    MODELS_AVAILABLE = True
except ImportError as exc:
    MODELS_AVAILABLE = False

metadata_entity_model_schema = json.loads(
    r"""{
  "type" : "object",
  "properties" : {
    "provider" : {
      "$ref" : "#/components/schemas/Provider"
    },
    "providerId" : {
      "type" : "string",
      "example" : "provider_123"
    },
    "customer" : {
      "$ref" : "#/components/schemas/Customer"
    },
    "firmware" : {
      "type" : "string",
      "example" : "1.21234"
    },
    "location" : {
      "$ref" : "#/components/schemas/MetadataEntity_location"
    },
    "metrics" : {
      "type" : "array",
      "description" : "A documentation of possible measurements that are to be expected on\n_Waylay Events_ associated with this _Resource_.",
      "items" : {
        "$ref" : "#/components/schemas/ResourceMetric"
      }
    },
    "sensors" : {
      "type" : "array",
      "description" : "Set of sensors that are applicable for a given _Resource_.\nPlease note that there is no explicit action taken by the Waylay platform on this meta key.\nThe idea behind this abstraction is to assist integrations where an architect of the digital twin\ncan specify which sensors from waylay library are applicable for a given _Resource_ (or _Resource Type_).",
      "items" : {
        "$ref" : "#/components/schemas/ResourceSensor"
      }
    }
  },
  "additionalProperties" : {
    "$ref" : "#/components/schemas/User_Resource_properties"
  },
  "description" : "Common attributes for _Resource_ or _Resource Type_"
}
""",
    object_hook=with_example_provider,
)
metadata_entity_model_schema.update({"definitions": MODEL_DEFINITIONS})

metadata_entity_faker = JSF(metadata_entity_model_schema, allow_none_optionals=1)


class MetadataEntityStub:
    """MetadataEntity unit test stubs."""

    @classmethod
    def create_json(cls):
        """Create a dict stub instance."""
        return metadata_entity_faker.generate(use_defaults=True, use_examples=True)

    @classmethod
    def create_instance(cls) -> "MetadataEntity":
        """Create MetadataEntity stub instance."""
        if not MODELS_AVAILABLE:
            raise ImportError("Models must be installed to create class stubs")
        json = cls.create_json()
        if json is None:
            # use backup example based on the pydantic model schema
            backup_faker = JSF(
                MetadataEntityAdapter.json_schema(), allow_none_optionals=1
            )
            json = backup_faker.generate(use_defaults=True, use_examples=True)
        return MetadataEntityAdapter.validate_python(
            json, context={"skip_validation": True}
        )
