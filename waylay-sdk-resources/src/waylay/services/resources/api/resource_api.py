# coding: utf-8
"""Waylay Resources api.

This code was generated from the OpenAPI documentation of 'Waylay Resources'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9

from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Literal,
    TypeVar,
    overload,
)

from pydantic import (
    Field,
    StrictBool,
    StrictStr,
    TypeAdapter,
)
from typing_extensions import (
    Annotated,  # >=3.9,
)
from waylay.sdk.api import (
    HeaderTypes,
    QueryParamTypes,
    Response,
)
from waylay.sdk.api._models import Model
from waylay.sdk.plugin import WithApiClient

if TYPE_CHECKING:
    from waylay.services.resources.models import (
        ErrorResponse,
        PatchResourceEntity,
        ResourceChange,
        ResourceCreationResponse,
        ResourceEntity,
        ResourceListing,
        ResourceWithIdEntity,
        ValidationFailure,
    )
    from waylay.services.resources.queries.resource_api import (
        CreateQuery,
        DeleteQuery,
        GetQuery,
        ListChangesQuery,
        ListChildrenQuery,
        ListQuery,
        ListReferrersQuery,
        PatchQuery,
        ReplaceQuery,
    )


try:
    from waylay.services.resources.models import (
        ErrorResponse,
        PatchResourceEntity,
        ResourceChange,
        ResourceCreationResponse,
        ResourceEntity,
        ResourceListing,
        ResourceWithIdEntity,
        ValidationFailure,
    )
    from waylay.services.resources.queries.resource_api import (
        CreateQuery,
        DeleteQuery,
        GetQuery,
        ListChangesQuery,
        ListChildrenQuery,
        ListQuery,
        ListReferrersQuery,
        PatchQuery,
        ReplaceQuery,
    )

    MODELS_AVAILABLE = True
except ImportError:
    MODELS_AVAILABLE = False

    if not TYPE_CHECKING:
        ResourceEntity = Model

        CreateQuery = dict
        ResourceCreationResponse = Model

        ValidationFailure = Model

        ErrorResponse = Model

        DeleteQuery = dict

        ErrorResponse = Model

        ErrorResponse = Model

        GetQuery = dict
        ResourceWithIdEntity = Model

        ErrorResponse = Model

        ListChangesQuery = dict
        ResourceChange = Model

        ErrorResponse = Model

        ListChildrenQuery = dict
        ResourceListing = Model

        ErrorResponse = Model

        ListReferrersQuery = dict
        ResourceListing = Model

        ErrorResponse = Model

        ListQuery = dict
        ResourceListing = Model

        ErrorResponse = Model

        PatchResourceEntity = Model

        PatchQuery = dict
        ResourceWithIdEntity = Model

        ValidationFailure = Model

        ResourceEntity = Model

        ReplaceQuery = dict
        ResourceWithIdEntity = Model

        ValidationFailure = Model


T = TypeVar("T")


class ResourceApi(WithApiClient):
    """ResourceApi service methods.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    @overload
    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceCreationResponse: ...

    @overload
    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def create(
        self,
        *,
        json: ResourceEntity,
        query: CreateQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceCreationResponse | T | Response | Model:
        """Create Resource.

        Creates a new _Resource_.
        :param json: The json request body.
        :type json: ResourceEntity, optional
        :param query: URL Query parameters.
        :type query: CreateQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and should_validate:
            body_adapter = TypeAdapter(ResourceEntity)
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(CreateQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "201": ResourceCreationResponse if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ValidationFailure,
            "409": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="POST",
            resource_path="/resources/v1/resources",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> None: ...

    @overload
    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> None: ...

    @overload
    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def delete(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: DeleteQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> None | T | Response:
        """Remove Resource.

        Removes an existing _Resource_.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param query: URL Query parameters.
        :type query: DeleteQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(DeleteQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "204": None,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="DELETE",
            resource_path="/resources/v1/resources/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity: ...

    @overload
    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def get(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: GetQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity | T | Response | Model:
        """Get Resource.

        Retrieves a representation of the _Resource_.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param query: URL Query parameters.
        :type query: GetQuery | QueryParamTypes, optional
        :param query['denormalized'] (dict) <br> query.denormalized (Query) : Unless explicitly set to `false`, attributes inherited from a linked _Resource Type_ will be included in the representation.
        :type query['denormalized']: bool
        :param query['field'] (dict) <br> query.field (Query) : Select which attributes to render for each matching _Resource_ (repeated).
        :type query['field']: List[str]
        :param query['fields'] (dict) <br> query.fields (Query) : Select which attributes to render for each matching _Resource_ (comma-separated).
        :type query['fields']: List[str]
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(GetQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceWithIdEntity if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/resources/v1/resources/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> List[ResourceChange]: ...

    @overload
    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_changes(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChangesQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> List[ResourceChange] | T | Response | Model:
        """List Resource Changes.

        Lists the change history of a _Resource_.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param query: URL Query parameters.
        :type query: ListChangesQuery | QueryParamTypes, optional
        :param query['skip'] (dict) <br> query.skip (Query) : (Paging) items to skip in the listing
        :type query['skip']: int
        :param query['limit'] (dict) <br> query.limit (Query) : (Paging) maximal number of items returned
        :type query['limit']: int
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(ListChangesQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": List[ResourceChange] if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/resources/v1/resources/{resourceId}/changes",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing: ...

    @overload
    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_children(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListChildrenQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing | T | Response | Model:
        """List Resource Children.

        Lists the children of a _Resource_, these are the _Resources_ that have the given _Resource_ referenced with the `parentId` attribute.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param query: URL Query parameters.
        :type query: ListChildrenQuery | QueryParamTypes, optional
        :param query['denormalized'] (dict) <br> query.denormalized (Query) : Unless explicitly set to `false`, attributes inherited from a linked _Resource Type_ will be included in the representation.
        :type query['denormalized']: bool
        :param query['field'] (dict) <br> query.field (Query) : Select which attributes to render for each matching _Resource_ (repeated).
        :type query['field']: List[str]
        :param query['fields'] (dict) <br> query.fields (Query) : Select which attributes to render for each matching _Resource_ (comma-separated).
        :type query['fields']: List[str]
        :param query['skip'] (dict) <br> query.skip (Query) : (Paging) items to skip in the listing
        :type query['skip']: int
        :param query['limit'] (dict) <br> query.limit (Query) : (Paging) maximal number of items returned
        :type query['limit']: int
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(ListChildrenQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceListing if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/resources/v1/resources/{resourceId}/children",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing: ...

    @overload
    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list_referrers(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        query: ListReferrersQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing | T | Response | Model:
        """List Referring Resources.

        List the _Resources_ that reference the given _Resource_.  #### visibility This definition has visibility status `beta`.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param query: URL Query parameters.
        :type query: ListReferrersQuery | QueryParamTypes, optional
        :param query['field'] (dict) <br> query.field (Query) : Select which attributes to render for each matching _Resource_ (repeated).
        :type query['field']: List[str]
        :param query['fields'] (dict) <br> query.fields (Query) : Select which attributes to render for each matching _Resource_ (comma-separated).
        :type query['fields']: List[str]
        :param query['skip'] (dict) <br> query.skip (Query) : (Paging) items to skip in the listing
        :type query['skip']: int
        :param query['limit'] (dict) <br> query.limit (Query) : (Paging) maximal number of items returned
        :type query['limit']: int
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(ListReferrersQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceListing if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "404": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/resources/v1/resources/{resourceId}/referrers",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def list(
        self,
        *,
        query: ListQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceListing | T | Response | Model:
        """Query Resources.

        Lists _Resources_ that satisfy the given filters.
        :param query: URL Query parameters.
        :type query: ListQuery | QueryParamTypes, optional
        :param query['skip'] (dict) <br> query.skip (Query) : (Paging) items to skip in the listing
        :type query['skip']: int
        :param query['limit'] (dict) <br> query.limit (Query) : (Paging) maximal number of items returned
        :type query['limit']: int
        :param query['field'] (dict) <br> query.field (Query) : Select which attributes to render for each matching _Resource_ (repeated).
        :type query['field']: List[str]
        :param query['fields'] (dict) <br> query.fields (Query) : Select which attributes to render for each matching _Resource_ (comma-separated).
        :type query['fields']: List[str]
        :param query['filter'] (dict) <br> query.filter (Query) : (Filter) fuzzy search on multiple fields.
        :type query['filter']: str
        :param query['query'] (dict) <br> query.query (Query) : Search string using a query language consisting of > `<metadata key>:<operation>(<arguments>)`  Supported operations are - `eq`: equals - exact match - `in`: in - exact match - arguments are a (comma-separated) list of values - `lt`: smaller then - `lte`: smaller then or equal - `gt`: greater then - `gte`: greater then or equal - `ref`: references - argument should be uri /resources/<resourceId> - `exists`: check if the _Resource_ has the specified metadata key - no argument allowed - `like`: wildcard search - argument should contain * and/or ?  For more info see [Waylay Docs](/#/api/resources/?id=metadata-query-language)
        :type query['query']: str
        :param query['tag'] (dict) <br> query.tag (Query) :
        :type query['tag']: List[str]
        :param query['id'] (dict) <br> query.id (Query) :
        :type query['id']: List[ResourceId]
        :param query['provider'] (dict) <br> query.provider (Query) :
        :type query['provider']: str
        :param query['customer'] (dict) <br> query.customer (Query) :
        :type query['customer']: str
        :param query['resourceTypeId'] (dict) <br> query.resource_type_id (Query) :
        :type query['resourceTypeId']: ResourceTypeId
        :param query['lat'] (dict) <br> query.lat (Query) :
        :type query['lat']: float
        :param query['lon'] (dict) <br> query.lon (Query) :
        :type query['lon']: float
        :param query['distance'] (dict) <br> query.distance (Query) :
        :type query['distance']: str
        :param query['toplevelOnly'] (dict) <br> query.toplevel_only (Query) : If true, search only for _Resources_ without parent.
        :type query['toplevelOnly']: bool
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {}

        ## named body parameters
        body_args: Dict[str, Any] = {}

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(ListQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceListing if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ErrorResponse,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="GET",
            resource_path="/resources/v1/resources",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity: ...

    @overload
    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def patch(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: PatchResourceEntity,
        query: PatchQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity | T | Response | Model:
        """Create Or Update Resource Partially.

        Updates some attributes of an existing _Resource_, or creates a new one.  When updating an existing _Resource_ you can remove keys by setting their value to `null` in the body
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param json: The json request body.
        :type json: PatchResourceEntity, optional
        :param query: URL Query parameters.
        :type query: PatchQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and should_validate:
            body_adapter = TypeAdapter(PatchResourceEntity)
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(PatchQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceWithIdEntity if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ValidationFailure,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PATCH",
            resource_path="/resources/v1/resources/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )

    @overload
    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity: ...

    @overload
    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: Literal[""] = "",
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    @overload
    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[True],
        select_path: Literal["_not_used_"] = "_not_used_",
        response_type: Literal[None] = None,  # not used
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Response: ...

    @overload
    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: Literal[None] = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> Model: ...

    @overload
    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: Literal[False] = False,
        select_path: str,
        response_type: T,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> T: ...

    async def replace(
        self,
        resource_id: Annotated[StrictStr, Field(description="_Resource_ id")],
        *,
        json: ResourceEntity,
        query: ReplaceQuery | QueryParamTypes | None = None,
        raw_response: StrictBool = False,
        select_path: str = "",
        response_type: T | None = None,
        headers: HeaderTypes | None = None,
        **kwargs,
    ) -> ResourceWithIdEntity | T | Response | Model:
        """Update Resource.

        Replaces a _Resource_ with a new representation.
        :param resource_id: _Resource_ id (required)
        :type resource_id: ResourceId
        :param json: The json request body.
        :type json: ResourceEntity, optional
        :param query: URL Query parameters.
        :type query: ReplaceQuery | QueryParamTypes, optional
        :param raw_response: If true, return the http Response object instead of returning an api model object, or throwing an ApiError.
        :param select_path: Denotes the json path applied to the response object before returning it.
                Set it to the empty string `""` to receive the full response object.
        :param response_type: If specified, the response is parsed into an instance of the specified type.
        :param headers: Header parameters for this request
        :type headers: dict, optional
        :param `**kwargs`: Additional parameters passed on to the http client.
            See below.
        :Keyword Arguments:
            * timeout: a single numeric timeout in seconds,
                or a tuple of _connect_, _read_, _write_ and _pool_ timeouts.
            * stream: if true, the response will be in streaming mode
            * cookies
            * extensions
            * auth
            * follow_redirects: bool

        :return: Returns the result object if the http request succeeded with status code '2XX'.
        :raises APIError: If the http request has a status code different from `2XX`. This
            object wraps both the http Response and any parsed data.
        """

        should_validate = (
            MODELS_AVAILABLE and self.api_client.config.client_side_validation
        )

        # path parameters
        path_params: Dict[str, str] = {
            "resourceId": str(resource_id),
        }

        ## named body parameters
        body_args: Dict[str, Any] = {}
        if json is not None and should_validate:
            body_adapter = TypeAdapter(ResourceEntity)
            json = body_adapter.validate_python(json)  # type: ignore # https://github.com/pydantic/pydantic/discussions/7094
        body_args["json"] = json

        # query parameters
        if query is not None and should_validate:
            query = TypeAdapter(ReplaceQuery).validate_python(query)

        response_types_map: Dict[str, Any] = (
            {"2XX": response_type}
            if response_type is not None
            else {
                "200": ResourceWithIdEntity if not select_path else Model,
            }
        )
        non_200_response_types_map: Dict[str, Any] = {
            "400": ValidationFailure,
        }
        response_types_map.update(non_200_response_types_map)

        ## peform request
        return await self.api_client.request(
            method="PUT",
            resource_path="/resources/v1/resources/{resourceId}",
            path_params=path_params,
            params=query,
            **body_args,
            headers=headers,
            **kwargs,
            response_type=response_types_map,
            select_path=select_path,
            raw_response=raw_response,
        )
